// **********************************************************************
//
// Copyright (c) 2003-2017 ZeroC, Inc. All rights reserved.
//
// This copy of Ice is licensed to you under the terms described in the
// ICE_LICENSE file included in this distribution.
//
// **********************************************************************
//
// Ice version 3.6.4
//
// <auto-generated>
//
// Generated from file `fepxb.ice'
//
// Warning: do not edit this file.
//
// </auto-generated>
//

#ifndef __cpp_fepxb_h__
#define __cpp_fepxb_h__

#include <IceUtil/PushDisableWarnings.h>
#include <Ice/ProxyF.h>
#include <Ice/ObjectF.h>
#include <Ice/Exception.h>
#include <Ice/LocalObject.h>
#include <Ice/StreamHelpers.h>
#include <Ice/Proxy.h>
#include <Ice/GCObject.h>
#include <Ice/AsyncResult.h>
#include <Ice/Incoming.h>
#include <IceUtil/ScopedArray.h>
#include <IceUtil/Optional.h>
#include <Ice/StreamF.h>
#include <IceUtil/UndefSysMacros.h>

#ifndef ICE_IGNORE_VERSION
#   if ICE_INT_VERSION / 100 != 306
#       error Ice version mismatch!
#   endif
#   if ICE_INT_VERSION % 100 > 50
#       error Beta header file detected
#   endif
#   if ICE_INT_VERSION % 100 < 4
#       error Ice patch level mismatch!
#   endif
#endif

namespace IceProxy
{

namespace FepXbData
{

class CFepXb;
void __read(::IceInternal::BasicStream*, ::IceInternal::ProxyHandle< ::IceProxy::FepXbData::CFepXb>&);
::IceProxy::Ice::Object* upCast(::IceProxy::FepXbData::CFepXb*);

}

}

namespace FepXbData
{

class CFepXb;
::Ice::Object* upCast(::FepXbData::CFepXb*);
typedef ::IceInternal::Handle< ::FepXbData::CFepXb> CFepXbPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::FepXbData::CFepXb> CFepXbPrx;
void __patch(CFepXbPtr&, const ::Ice::ObjectPtr&);

}

namespace FepXbData
{

typedef ::std::vector< ::Ice::Byte> byteSeq;

typedef ::std::vector< ::std::string> stringSeq;

typedef ::std::vector< ::Ice::Short> shortSeq;

struct SDevicePara1
{
    ::std::string SettingFlag;
    ::Ice::Byte Version;
    ::Ice::Byte ChannelCheckCode;
    ::Ice::Byte FilterWidth;
    ::Ice::Byte FilterCtrlCode;
    ::Ice::Byte ChannelNum;
    ::Ice::Byte SamplingRate;
    ::Ice::Byte Rs;
    ::Ice::Byte RecordLength;
    ::Ice::Short TriggerInterval;
    ::Ice::Byte WorkFrequence;
    ::Ice::Byte YearL;
    ::Ice::Byte YearH;
    ::Ice::Byte IrigB;
    ::Ice::Byte Flash;
    ::Ice::Byte TDUStaAddr;
    ::std::string DevID;
    ::std::string StatName;
    ::FepXbData::stringSeq LineName;
    ::FepXbData::byteSeq ChnlsLineNum;
    ::Ice::Byte TimeZoneHour;
    ::Ice::Byte TimeZoneMinute;
    ::Ice::Byte Rsved;
};

struct SDevicePara2
{
    ::FepXbData::byteSeq EnChAndIsInvertPhase;
    ::FepXbData::byteSeq AIBoardTypeAndMesures;
    ::FepXbData::byteSeq DI;
    ::FepXbData::byteSeq DI2;
    ::FepXbData::shortSeq VarRatio;
    ::FepXbData::byteSeq VarRatioVice;
    ::FepXbData::shortSeq VolLevel;
    ::FepXbData::byteSeq ChannelGain;
    ::FepXbData::byteSeq TriggerThreshold;
    ::FepXbData::byteSeq LineCurrent;
    ::FepXbData::byteSeq LineVICorrection;
    ::FepXbData::byteSeq StartPara;
    ::FepXbData::byteSeq GainPara;
};

struct SCommPara
{
    ::FepXbData::byteSeq MACAddr1;
    ::FepXbData::byteSeq IPAddr1;
    ::FepXbData::byteSeq NetMask1;
    ::FepXbData::byteSeq Gateway1;
    ::Ice::Short Port1;
    ::FepXbData::byteSeq MACAddr2;
    ::FepXbData::byteSeq IPAddr2;
    ::FepXbData::byteSeq NetMask2;
    ::FepXbData::byteSeq Gateway2;
    ::Ice::Short Port2;
    ::Ice::Short NetReserve;
    ::FepXbData::byteSeq remoteIP1;
    ::Ice::Short remotePort1;
    ::FepXbData::byteSeq remoteIP2;
    ::Ice::Short remotePort2;
    ::Ice::Byte Com1ProtocolType;
    ::FepXbData::byteSeq Com1ProtocolPara;
    ::Ice::Byte LinkAddr103;
    ::Ice::Byte FunType103;
    ::Ice::Byte Com2ProtocolType;
    ::FepXbData::byteSeq Com2ProtocolPara;
    ::Ice::Byte LinkAddr2103;
    ::Ice::Byte FunType2103;
    ::std::string ModemPhone;
    ::std::string ModemInitCmd;
    ::Ice::Byte ModemState;
    ::Ice::Byte Rsved3;
};

struct TduCfg
{
    ::FepXbData::SDevicePara1 DevicePara1;
    ::FepXbData::SDevicePara2 DevicePara2;
    ::FepXbData::SCommPara CommPara;
};

struct SettingValueInfo
{
    ::Ice::Short unitNo;
    ::FepXbData::TduCfg tdu100Cfg;
};

struct SAC
{
    bool bIsOverLimit;
    ::Ice::Int nBelongToLine;
    ::Ice::Int nMeasureType;

    bool operator==(const SAC& __rhs) const
    {
        if(this == &__rhs)
        {
            return true;
        }
        if(bIsOverLimit != __rhs.bIsOverLimit)
        {
            return false;
        }
        if(nBelongToLine != __rhs.nBelongToLine)
        {
            return false;
        }
        if(nMeasureType != __rhs.nMeasureType)
        {
            return false;
        }
        return true;
    }

    bool operator<(const SAC& __rhs) const
    {
        if(this == &__rhs)
        {
            return false;
        }
        if(bIsOverLimit < __rhs.bIsOverLimit)
        {
            return true;
        }
        else if(__rhs.bIsOverLimit < bIsOverLimit)
        {
            return false;
        }
        if(nBelongToLine < __rhs.nBelongToLine)
        {
            return true;
        }
        else if(__rhs.nBelongToLine < nBelongToLine)
        {
            return false;
        }
        if(nMeasureType < __rhs.nMeasureType)
        {
            return true;
        }
        else if(__rhs.nMeasureType < nMeasureType)
        {
            return false;
        }
        return false;
    }

    bool operator!=(const SAC& __rhs) const
    {
        return !operator==(__rhs);
    }
    bool operator<=(const SAC& __rhs) const
    {
        return operator<(__rhs) || operator==(__rhs);
    }
    bool operator>(const SAC& __rhs) const
    {
        return !operator<(__rhs) && !operator==(__rhs);
    }
    bool operator>=(const SAC& __rhs) const
    {
        return !operator<(__rhs);
    }
};

struct SChannelData
{
    ::FepXbData::SAC sSAC;
    ::Ice::Short wFreqCurrentM;

    bool operator==(const SChannelData& __rhs) const
    {
        if(this == &__rhs)
        {
            return true;
        }
        if(sSAC != __rhs.sSAC)
        {
            return false;
        }
        if(wFreqCurrentM != __rhs.wFreqCurrentM)
        {
            return false;
        }
        return true;
    }

    bool operator<(const SChannelData& __rhs) const
    {
        if(this == &__rhs)
        {
            return false;
        }
        if(sSAC < __rhs.sSAC)
        {
            return true;
        }
        else if(__rhs.sSAC < sSAC)
        {
            return false;
        }
        if(wFreqCurrentM < __rhs.wFreqCurrentM)
        {
            return true;
        }
        else if(__rhs.wFreqCurrentM < wFreqCurrentM)
        {
            return false;
        }
        return false;
    }

    bool operator!=(const SChannelData& __rhs) const
    {
        return !operator==(__rhs);
    }
    bool operator<=(const SChannelData& __rhs) const
    {
        return operator<(__rhs) || operator==(__rhs);
    }
    bool operator>(const SChannelData& __rhs) const
    {
        return !operator<(__rhs) && !operator==(__rhs);
    }
    bool operator>=(const SChannelData& __rhs) const
    {
        return !operator<(__rhs);
    }
};

typedef ::std::vector< ::FepXbData::SChannelData> SChannelDataSeq;

struct STriggerTime
{
    ::Ice::Int nTimeType;
    ::std::string szTimeString;
    ::Ice::Double dUs;
};

struct TduBrief
{
    ::Ice::Short unitNo;
    ::Ice::Int FileType;
    bool bIsDial;
    ::FepXbData::STriggerTime sTriggerTime;
    ::Ice::Int nTriggerType;
    ::Ice::Int nStartChannel;
    ::Ice::Int nTriggerChannel;
    bool bIsOverLimit;
    ::Ice::Int nFaultPhase;
    ::FepXbData::SChannelDataSeq sChannelInfo;
};

struct AlarmTime
{
    ::Ice::Int year;
    ::Ice::Int month;
    ::Ice::Int day;
    ::Ice::Int hour;
    ::Ice::Int minute;
    ::Ice::Int second;
    ::Ice::Int milliseconds;

    bool operator==(const AlarmTime& __rhs) const
    {
        if(this == &__rhs)
        {
            return true;
        }
        if(year != __rhs.year)
        {
            return false;
        }
        if(month != __rhs.month)
        {
            return false;
        }
        if(day != __rhs.day)
        {
            return false;
        }
        if(hour != __rhs.hour)
        {
            return false;
        }
        if(minute != __rhs.minute)
        {
            return false;
        }
        if(second != __rhs.second)
        {
            return false;
        }
        if(milliseconds != __rhs.milliseconds)
        {
            return false;
        }
        return true;
    }

    bool operator<(const AlarmTime& __rhs) const
    {
        if(this == &__rhs)
        {
            return false;
        }
        if(year < __rhs.year)
        {
            return true;
        }
        else if(__rhs.year < year)
        {
            return false;
        }
        if(month < __rhs.month)
        {
            return true;
        }
        else if(__rhs.month < month)
        {
            return false;
        }
        if(day < __rhs.day)
        {
            return true;
        }
        else if(__rhs.day < day)
        {
            return false;
        }
        if(hour < __rhs.hour)
        {
            return true;
        }
        else if(__rhs.hour < hour)
        {
            return false;
        }
        if(minute < __rhs.minute)
        {
            return true;
        }
        else if(__rhs.minute < minute)
        {
            return false;
        }
        if(second < __rhs.second)
        {
            return true;
        }
        else if(__rhs.second < second)
        {
            return false;
        }
        if(milliseconds < __rhs.milliseconds)
        {
            return true;
        }
        else if(__rhs.milliseconds < milliseconds)
        {
            return false;
        }
        return false;
    }

    bool operator!=(const AlarmTime& __rhs) const
    {
        return !operator==(__rhs);
    }
    bool operator<=(const AlarmTime& __rhs) const
    {
        return operator<(__rhs) || operator==(__rhs);
    }
    bool operator>(const AlarmTime& __rhs) const
    {
        return !operator<(__rhs) && !operator==(__rhs);
    }
    bool operator>=(const AlarmTime& __rhs) const
    {
        return !operator<(__rhs);
    }
};

struct XbSOE
{
    ::Ice::Short unitNo;
    ::FepXbData::AlarmTime soeTime;
    ::Ice::Short Di1;
    ::Ice::Short Di2;
    ::Ice::Short Val;
    bool Alarm;
    bool Update;

    bool operator==(const XbSOE& __rhs) const
    {
        if(this == &__rhs)
        {
            return true;
        }
        if(unitNo != __rhs.unitNo)
        {
            return false;
        }
        if(soeTime != __rhs.soeTime)
        {
            return false;
        }
        if(Di1 != __rhs.Di1)
        {
            return false;
        }
        if(Di2 != __rhs.Di2)
        {
            return false;
        }
        if(Val != __rhs.Val)
        {
            return false;
        }
        if(Alarm != __rhs.Alarm)
        {
            return false;
        }
        if(Update != __rhs.Update)
        {
            return false;
        }
        return true;
    }

    bool operator<(const XbSOE& __rhs) const
    {
        if(this == &__rhs)
        {
            return false;
        }
        if(unitNo < __rhs.unitNo)
        {
            return true;
        }
        else if(__rhs.unitNo < unitNo)
        {
            return false;
        }
        if(soeTime < __rhs.soeTime)
        {
            return true;
        }
        else if(__rhs.soeTime < soeTime)
        {
            return false;
        }
        if(Di1 < __rhs.Di1)
        {
            return true;
        }
        else if(__rhs.Di1 < Di1)
        {
            return false;
        }
        if(Di2 < __rhs.Di2)
        {
            return true;
        }
        else if(__rhs.Di2 < Di2)
        {
            return false;
        }
        if(Val < __rhs.Val)
        {
            return true;
        }
        else if(__rhs.Val < Val)
        {
            return false;
        }
        if(Alarm < __rhs.Alarm)
        {
            return true;
        }
        else if(__rhs.Alarm < Alarm)
        {
            return false;
        }
        if(Update < __rhs.Update)
        {
            return true;
        }
        else if(__rhs.Update < Update)
        {
            return false;
        }
        return false;
    }

    bool operator!=(const XbSOE& __rhs) const
    {
        return !operator==(__rhs);
    }
    bool operator<=(const XbSOE& __rhs) const
    {
        return operator<(__rhs) || operator==(__rhs);
    }
    bool operator>(const XbSOE& __rhs) const
    {
        return !operator<(__rhs) && !operator==(__rhs);
    }
    bool operator>=(const XbSOE& __rhs) const
    {
        return !operator<(__rhs);
    }
};

typedef ::std::vector< ::FepXbData::XbSOE> XbSOESeq;

struct XbDiscrete
{
    ::Ice::Short unitNo;
    ::FepXbData::AlarmTime disTime;
    ::Ice::Short No;
    ::Ice::Short Val;
    bool Alarm;
    bool Update;

    bool operator==(const XbDiscrete& __rhs) const
    {
        if(this == &__rhs)
        {
            return true;
        }
        if(unitNo != __rhs.unitNo)
        {
            return false;
        }
        if(disTime != __rhs.disTime)
        {
            return false;
        }
        if(No != __rhs.No)
        {
            return false;
        }
        if(Val != __rhs.Val)
        {
            return false;
        }
        if(Alarm != __rhs.Alarm)
        {
            return false;
        }
        if(Update != __rhs.Update)
        {
            return false;
        }
        return true;
    }

    bool operator<(const XbDiscrete& __rhs) const
    {
        if(this == &__rhs)
        {
            return false;
        }
        if(unitNo < __rhs.unitNo)
        {
            return true;
        }
        else if(__rhs.unitNo < unitNo)
        {
            return false;
        }
        if(disTime < __rhs.disTime)
        {
            return true;
        }
        else if(__rhs.disTime < disTime)
        {
            return false;
        }
        if(No < __rhs.No)
        {
            return true;
        }
        else if(__rhs.No < No)
        {
            return false;
        }
        if(Val < __rhs.Val)
        {
            return true;
        }
        else if(__rhs.Val < Val)
        {
            return false;
        }
        if(Alarm < __rhs.Alarm)
        {
            return true;
        }
        else if(__rhs.Alarm < Alarm)
        {
            return false;
        }
        if(Update < __rhs.Update)
        {
            return true;
        }
        else if(__rhs.Update < Update)
        {
            return false;
        }
        return false;
    }

    bool operator!=(const XbDiscrete& __rhs) const
    {
        return !operator==(__rhs);
    }
    bool operator<=(const XbDiscrete& __rhs) const
    {
        return operator<(__rhs) || operator==(__rhs);
    }
    bool operator>(const XbDiscrete& __rhs) const
    {
        return !operator<(__rhs) && !operator==(__rhs);
    }
    bool operator>=(const XbDiscrete& __rhs) const
    {
        return !operator<(__rhs);
    }
};

typedef ::std::vector< ::FepXbData::XbDiscrete> XbDiscreteSeq;

struct XbUnitStatus
{
    ::Ice::Short type;
    ::Ice::Short unitNo;
    ::FepXbData::AlarmTime disTime;
    ::Ice::Short UnitState;
    ::Ice::Short ChannelState;
    ::Ice::Short ErrorRate;

    bool operator==(const XbUnitStatus& __rhs) const
    {
        if(this == &__rhs)
        {
            return true;
        }
        if(type != __rhs.type)
        {
            return false;
        }
        if(unitNo != __rhs.unitNo)
        {
            return false;
        }
        if(disTime != __rhs.disTime)
        {
            return false;
        }
        if(UnitState != __rhs.UnitState)
        {
            return false;
        }
        if(ChannelState != __rhs.ChannelState)
        {
            return false;
        }
        if(ErrorRate != __rhs.ErrorRate)
        {
            return false;
        }
        return true;
    }

    bool operator<(const XbUnitStatus& __rhs) const
    {
        if(this == &__rhs)
        {
            return false;
        }
        if(type < __rhs.type)
        {
            return true;
        }
        else if(__rhs.type < type)
        {
            return false;
        }
        if(unitNo < __rhs.unitNo)
        {
            return true;
        }
        else if(__rhs.unitNo < unitNo)
        {
            return false;
        }
        if(disTime < __rhs.disTime)
        {
            return true;
        }
        else if(__rhs.disTime < disTime)
        {
            return false;
        }
        if(UnitState < __rhs.UnitState)
        {
            return true;
        }
        else if(__rhs.UnitState < UnitState)
        {
            return false;
        }
        if(ChannelState < __rhs.ChannelState)
        {
            return true;
        }
        else if(__rhs.ChannelState < ChannelState)
        {
            return false;
        }
        if(ErrorRate < __rhs.ErrorRate)
        {
            return true;
        }
        else if(__rhs.ErrorRate < ErrorRate)
        {
            return false;
        }
        return false;
    }

    bool operator!=(const XbUnitStatus& __rhs) const
    {
        return !operator==(__rhs);
    }
    bool operator<=(const XbUnitStatus& __rhs) const
    {
        return operator<(__rhs) || operator==(__rhs);
    }
    bool operator>(const XbUnitStatus& __rhs) const
    {
        return !operator<(__rhs) && !operator==(__rhs);
    }
    bool operator>=(const XbUnitStatus& __rhs) const
    {
        return !operator<(__rhs);
    }
};

typedef ::std::vector< ::FepXbData::XbUnitStatus> XbUnitStatusSeq;

struct XbWave
{
    ::Ice::Short unitNo;
    ::std::string FileName;
    ::FepXbData::byteSeq Wave;
    bool Start;
    bool End;
};

const ::std::string FepXbTopic = "fep_xb_data";

}

namespace Ice
{
template<>
struct StreamableTraits< ::FepXbData::SDevicePara1>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 24;
    static const bool fixedLength = false;
};

template<class S>
struct StreamWriter< ::FepXbData::SDevicePara1, S>
{
    static void write(S* __os, const ::FepXbData::SDevicePara1& v)
    {
        __os->write(v.SettingFlag);
        __os->write(v.Version);
        __os->write(v.ChannelCheckCode);
        __os->write(v.FilterWidth);
        __os->write(v.FilterCtrlCode);
        __os->write(v.ChannelNum);
        __os->write(v.SamplingRate);
        __os->write(v.Rs);
        __os->write(v.RecordLength);
        __os->write(v.TriggerInterval);
        __os->write(v.WorkFrequence);
        __os->write(v.YearL);
        __os->write(v.YearH);
        __os->write(v.IrigB);
        __os->write(v.Flash);
        __os->write(v.TDUStaAddr);
        __os->write(v.DevID);
        __os->write(v.StatName);
        __os->write(v.LineName);
        __os->write(v.ChnlsLineNum);
        __os->write(v.TimeZoneHour);
        __os->write(v.TimeZoneMinute);
        __os->write(v.Rsved);
    }
};

template<class S>
struct StreamReader< ::FepXbData::SDevicePara1, S>
{
    static void read(S* __is, ::FepXbData::SDevicePara1& v)
    {
        __is->read(v.SettingFlag);
        __is->read(v.Version);
        __is->read(v.ChannelCheckCode);
        __is->read(v.FilterWidth);
        __is->read(v.FilterCtrlCode);
        __is->read(v.ChannelNum);
        __is->read(v.SamplingRate);
        __is->read(v.Rs);
        __is->read(v.RecordLength);
        __is->read(v.TriggerInterval);
        __is->read(v.WorkFrequence);
        __is->read(v.YearL);
        __is->read(v.YearH);
        __is->read(v.IrigB);
        __is->read(v.Flash);
        __is->read(v.TDUStaAddr);
        __is->read(v.DevID);
        __is->read(v.StatName);
        __is->read(v.LineName);
        __is->read(v.ChnlsLineNum);
        __is->read(v.TimeZoneHour);
        __is->read(v.TimeZoneMinute);
        __is->read(v.Rsved);
    }
};

template<>
struct StreamableTraits< ::FepXbData::SDevicePara2>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 13;
    static const bool fixedLength = false;
};

template<class S>
struct StreamWriter< ::FepXbData::SDevicePara2, S>
{
    static void write(S* __os, const ::FepXbData::SDevicePara2& v)
    {
        __os->write(v.EnChAndIsInvertPhase);
        __os->write(v.AIBoardTypeAndMesures);
        __os->write(v.DI);
        __os->write(v.DI2);
        __os->write(v.VarRatio);
        __os->write(v.VarRatioVice);
        __os->write(v.VolLevel);
        __os->write(v.ChannelGain);
        __os->write(v.TriggerThreshold);
        __os->write(v.LineCurrent);
        __os->write(v.LineVICorrection);
        __os->write(v.StartPara);
        __os->write(v.GainPara);
    }
};

template<class S>
struct StreamReader< ::FepXbData::SDevicePara2, S>
{
    static void read(S* __is, ::FepXbData::SDevicePara2& v)
    {
        __is->read(v.EnChAndIsInvertPhase);
        __is->read(v.AIBoardTypeAndMesures);
        __is->read(v.DI);
        __is->read(v.DI2);
        __is->read(v.VarRatio);
        __is->read(v.VarRatioVice);
        __is->read(v.VolLevel);
        __is->read(v.ChannelGain);
        __is->read(v.TriggerThreshold);
        __is->read(v.LineCurrent);
        __is->read(v.LineVICorrection);
        __is->read(v.StartPara);
        __is->read(v.GainPara);
    }
};

template<>
struct StreamableTraits< ::FepXbData::SCommPara>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 32;
    static const bool fixedLength = false;
};

template<class S>
struct StreamWriter< ::FepXbData::SCommPara, S>
{
    static void write(S* __os, const ::FepXbData::SCommPara& v)
    {
        __os->write(v.MACAddr1);
        __os->write(v.IPAddr1);
        __os->write(v.NetMask1);
        __os->write(v.Gateway1);
        __os->write(v.Port1);
        __os->write(v.MACAddr2);
        __os->write(v.IPAddr2);
        __os->write(v.NetMask2);
        __os->write(v.Gateway2);
        __os->write(v.Port2);
        __os->write(v.NetReserve);
        __os->write(v.remoteIP1);
        __os->write(v.remotePort1);
        __os->write(v.remoteIP2);
        __os->write(v.remotePort2);
        __os->write(v.Com1ProtocolType);
        __os->write(v.Com1ProtocolPara);
        __os->write(v.LinkAddr103);
        __os->write(v.FunType103);
        __os->write(v.Com2ProtocolType);
        __os->write(v.Com2ProtocolPara);
        __os->write(v.LinkAddr2103);
        __os->write(v.FunType2103);
        __os->write(v.ModemPhone);
        __os->write(v.ModemInitCmd);
        __os->write(v.ModemState);
        __os->write(v.Rsved3);
    }
};

template<class S>
struct StreamReader< ::FepXbData::SCommPara, S>
{
    static void read(S* __is, ::FepXbData::SCommPara& v)
    {
        __is->read(v.MACAddr1);
        __is->read(v.IPAddr1);
        __is->read(v.NetMask1);
        __is->read(v.Gateway1);
        __is->read(v.Port1);
        __is->read(v.MACAddr2);
        __is->read(v.IPAddr2);
        __is->read(v.NetMask2);
        __is->read(v.Gateway2);
        __is->read(v.Port2);
        __is->read(v.NetReserve);
        __is->read(v.remoteIP1);
        __is->read(v.remotePort1);
        __is->read(v.remoteIP2);
        __is->read(v.remotePort2);
        __is->read(v.Com1ProtocolType);
        __is->read(v.Com1ProtocolPara);
        __is->read(v.LinkAddr103);
        __is->read(v.FunType103);
        __is->read(v.Com2ProtocolType);
        __is->read(v.Com2ProtocolPara);
        __is->read(v.LinkAddr2103);
        __is->read(v.FunType2103);
        __is->read(v.ModemPhone);
        __is->read(v.ModemInitCmd);
        __is->read(v.ModemState);
        __is->read(v.Rsved3);
    }
};

template<>
struct StreamableTraits< ::FepXbData::TduCfg>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 69;
    static const bool fixedLength = false;
};

template<class S>
struct StreamWriter< ::FepXbData::TduCfg, S>
{
    static void write(S* __os, const ::FepXbData::TduCfg& v)
    {
        __os->write(v.DevicePara1);
        __os->write(v.DevicePara2);
        __os->write(v.CommPara);
    }
};

template<class S>
struct StreamReader< ::FepXbData::TduCfg, S>
{
    static void read(S* __is, ::FepXbData::TduCfg& v)
    {
        __is->read(v.DevicePara1);
        __is->read(v.DevicePara2);
        __is->read(v.CommPara);
    }
};

template<>
struct StreamableTraits< ::FepXbData::SettingValueInfo>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 71;
    static const bool fixedLength = false;
};

template<class S>
struct StreamWriter< ::FepXbData::SettingValueInfo, S>
{
    static void write(S* __os, const ::FepXbData::SettingValueInfo& v)
    {
        __os->write(v.unitNo);
        __os->write(v.tdu100Cfg);
    }
};

template<class S>
struct StreamReader< ::FepXbData::SettingValueInfo, S>
{
    static void read(S* __is, ::FepXbData::SettingValueInfo& v)
    {
        __is->read(v.unitNo);
        __is->read(v.tdu100Cfg);
    }
};

template<>
struct StreamableTraits< ::FepXbData::SAC>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 9;
    static const bool fixedLength = true;
};

template<class S>
struct StreamWriter< ::FepXbData::SAC, S>
{
    static void write(S* __os, const ::FepXbData::SAC& v)
    {
        __os->write(v.bIsOverLimit);
        __os->write(v.nBelongToLine);
        __os->write(v.nMeasureType);
    }
};

template<class S>
struct StreamReader< ::FepXbData::SAC, S>
{
    static void read(S* __is, ::FepXbData::SAC& v)
    {
        __is->read(v.bIsOverLimit);
        __is->read(v.nBelongToLine);
        __is->read(v.nMeasureType);
    }
};

template<>
struct StreamableTraits< ::FepXbData::SChannelData>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 11;
    static const bool fixedLength = true;
};

template<class S>
struct StreamWriter< ::FepXbData::SChannelData, S>
{
    static void write(S* __os, const ::FepXbData::SChannelData& v)
    {
        __os->write(v.sSAC);
        __os->write(v.wFreqCurrentM);
    }
};

template<class S>
struct StreamReader< ::FepXbData::SChannelData, S>
{
    static void read(S* __is, ::FepXbData::SChannelData& v)
    {
        __is->read(v.sSAC);
        __is->read(v.wFreqCurrentM);
    }
};

template<>
struct StreamableTraits< ::FepXbData::STriggerTime>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 13;
    static const bool fixedLength = false;
};

template<class S>
struct StreamWriter< ::FepXbData::STriggerTime, S>
{
    static void write(S* __os, const ::FepXbData::STriggerTime& v)
    {
        __os->write(v.nTimeType);
        __os->write(v.szTimeString);
        __os->write(v.dUs);
    }
};

template<class S>
struct StreamReader< ::FepXbData::STriggerTime, S>
{
    static void read(S* __is, ::FepXbData::STriggerTime& v)
    {
        __is->read(v.nTimeType);
        __is->read(v.szTimeString);
        __is->read(v.dUs);
    }
};

template<>
struct StreamableTraits< ::FepXbData::TduBrief>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 38;
    static const bool fixedLength = false;
};

template<class S>
struct StreamWriter< ::FepXbData::TduBrief, S>
{
    static void write(S* __os, const ::FepXbData::TduBrief& v)
    {
        __os->write(v.unitNo);
        __os->write(v.FileType);
        __os->write(v.bIsDial);
        __os->write(v.sTriggerTime);
        __os->write(v.nTriggerType);
        __os->write(v.nStartChannel);
        __os->write(v.nTriggerChannel);
        __os->write(v.bIsOverLimit);
        __os->write(v.nFaultPhase);
        __os->write(v.sChannelInfo);
    }
};

template<class S>
struct StreamReader< ::FepXbData::TduBrief, S>
{
    static void read(S* __is, ::FepXbData::TduBrief& v)
    {
        __is->read(v.unitNo);
        __is->read(v.FileType);
        __is->read(v.bIsDial);
        __is->read(v.sTriggerTime);
        __is->read(v.nTriggerType);
        __is->read(v.nStartChannel);
        __is->read(v.nTriggerChannel);
        __is->read(v.bIsOverLimit);
        __is->read(v.nFaultPhase);
        __is->read(v.sChannelInfo);
    }
};

template<>
struct StreamableTraits< ::FepXbData::AlarmTime>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 28;
    static const bool fixedLength = true;
};

template<class S>
struct StreamWriter< ::FepXbData::AlarmTime, S>
{
    static void write(S* __os, const ::FepXbData::AlarmTime& v)
    {
        __os->write(v.year);
        __os->write(v.month);
        __os->write(v.day);
        __os->write(v.hour);
        __os->write(v.minute);
        __os->write(v.second);
        __os->write(v.milliseconds);
    }
};

template<class S>
struct StreamReader< ::FepXbData::AlarmTime, S>
{
    static void read(S* __is, ::FepXbData::AlarmTime& v)
    {
        __is->read(v.year);
        __is->read(v.month);
        __is->read(v.day);
        __is->read(v.hour);
        __is->read(v.minute);
        __is->read(v.second);
        __is->read(v.milliseconds);
    }
};

template<>
struct StreamableTraits< ::FepXbData::XbSOE>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 38;
    static const bool fixedLength = true;
};

template<class S>
struct StreamWriter< ::FepXbData::XbSOE, S>
{
    static void write(S* __os, const ::FepXbData::XbSOE& v)
    {
        __os->write(v.unitNo);
        __os->write(v.soeTime);
        __os->write(v.Di1);
        __os->write(v.Di2);
        __os->write(v.Val);
        __os->write(v.Alarm);
        __os->write(v.Update);
    }
};

template<class S>
struct StreamReader< ::FepXbData::XbSOE, S>
{
    static void read(S* __is, ::FepXbData::XbSOE& v)
    {
        __is->read(v.unitNo);
        __is->read(v.soeTime);
        __is->read(v.Di1);
        __is->read(v.Di2);
        __is->read(v.Val);
        __is->read(v.Alarm);
        __is->read(v.Update);
    }
};

template<>
struct StreamableTraits< ::FepXbData::XbDiscrete>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 36;
    static const bool fixedLength = true;
};

template<class S>
struct StreamWriter< ::FepXbData::XbDiscrete, S>
{
    static void write(S* __os, const ::FepXbData::XbDiscrete& v)
    {
        __os->write(v.unitNo);
        __os->write(v.disTime);
        __os->write(v.No);
        __os->write(v.Val);
        __os->write(v.Alarm);
        __os->write(v.Update);
    }
};

template<class S>
struct StreamReader< ::FepXbData::XbDiscrete, S>
{
    static void read(S* __is, ::FepXbData::XbDiscrete& v)
    {
        __is->read(v.unitNo);
        __is->read(v.disTime);
        __is->read(v.No);
        __is->read(v.Val);
        __is->read(v.Alarm);
        __is->read(v.Update);
    }
};

template<>
struct StreamableTraits< ::FepXbData::XbUnitStatus>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 38;
    static const bool fixedLength = true;
};

template<class S>
struct StreamWriter< ::FepXbData::XbUnitStatus, S>
{
    static void write(S* __os, const ::FepXbData::XbUnitStatus& v)
    {
        __os->write(v.type);
        __os->write(v.unitNo);
        __os->write(v.disTime);
        __os->write(v.UnitState);
        __os->write(v.ChannelState);
        __os->write(v.ErrorRate);
    }
};

template<class S>
struct StreamReader< ::FepXbData::XbUnitStatus, S>
{
    static void read(S* __is, ::FepXbData::XbUnitStatus& v)
    {
        __is->read(v.type);
        __is->read(v.unitNo);
        __is->read(v.disTime);
        __is->read(v.UnitState);
        __is->read(v.ChannelState);
        __is->read(v.ErrorRate);
    }
};

template<>
struct StreamableTraits< ::FepXbData::XbWave>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 6;
    static const bool fixedLength = false;
};

template<class S>
struct StreamWriter< ::FepXbData::XbWave, S>
{
    static void write(S* __os, const ::FepXbData::XbWave& v)
    {
        __os->write(v.unitNo);
        __os->write(v.FileName);
        __os->write(v.Wave);
        __os->write(v.Start);
        __os->write(v.End);
    }
};

template<class S>
struct StreamReader< ::FepXbData::XbWave, S>
{
    static void read(S* __is, ::FepXbData::XbWave& v)
    {
        __is->read(v.unitNo);
        __is->read(v.FileName);
        __is->read(v.Wave);
        __is->read(v.Start);
        __is->read(v.End);
    }
};

}

namespace FepXbData
{

class Callback_CFepXb_sendSettingValue_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_CFepXb_sendSettingValue_Base> Callback_CFepXb_sendSettingValuePtr;

class Callback_CFepXb_sendBrief_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_CFepXb_sendBrief_Base> Callback_CFepXb_sendBriefPtr;

class Callback_CFepXb_sendSoe_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_CFepXb_sendSoe_Base> Callback_CFepXb_sendSoePtr;

class Callback_CFepXb_sendDiscrete_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_CFepXb_sendDiscrete_Base> Callback_CFepXb_sendDiscretePtr;

class Callback_CFepXb_sendUnitStatus_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_CFepXb_sendUnitStatus_Base> Callback_CFepXb_sendUnitStatusPtr;

class Callback_CFepXb_sendWave_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_CFepXb_sendWave_Base> Callback_CFepXb_sendWavePtr;

}

namespace IceProxy
{

namespace FepXbData
{

class CFepXb : virtual public ::IceProxy::Ice::Object
{
public:

    void sendSettingValue(const ::FepXbData::SettingValueInfo& __p_settingVal)
    {
        sendSettingValue(__p_settingVal, 0);
    }
    void sendSettingValue(const ::FepXbData::SettingValueInfo& __p_settingVal, const ::Ice::Context& __ctx)
    {
        sendSettingValue(__p_settingVal, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_sendSettingValue(const ::FepXbData::SettingValueInfo& __p_settingVal, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return begin_sendSettingValue(__p_settingVal, 0, new ::IceInternal::Cpp11FnOnewayCallbackNC(__response, __exception, __sent));
    }
    ::Ice::AsyncResultPtr
    begin_sendSettingValue(const ::FepXbData::SettingValueInfo& __p_settingVal, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_sendSettingValue(__p_settingVal, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_sendSettingValue(const ::FepXbData::SettingValueInfo& __p_settingVal, const ::Ice::Context& __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return begin_sendSettingValue(__p_settingVal, &__ctx, new ::IceInternal::Cpp11FnOnewayCallbackNC(__response, __exception, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_sendSettingValue(const ::FepXbData::SettingValueInfo& __p_settingVal, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_sendSettingValue(__p_settingVal, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
#endif

    ::Ice::AsyncResultPtr begin_sendSettingValue(const ::FepXbData::SettingValueInfo& __p_settingVal)
    {
        return begin_sendSettingValue(__p_settingVal, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_sendSettingValue(const ::FepXbData::SettingValueInfo& __p_settingVal, const ::Ice::Context& __ctx)
    {
        return begin_sendSettingValue(__p_settingVal, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_sendSettingValue(const ::FepXbData::SettingValueInfo& __p_settingVal, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_sendSettingValue(__p_settingVal, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_sendSettingValue(const ::FepXbData::SettingValueInfo& __p_settingVal, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_sendSettingValue(__p_settingVal, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_sendSettingValue(const ::FepXbData::SettingValueInfo& __p_settingVal, const ::FepXbData::Callback_CFepXb_sendSettingValuePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_sendSettingValue(__p_settingVal, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_sendSettingValue(const ::FepXbData::SettingValueInfo& __p_settingVal, const ::Ice::Context& __ctx, const ::FepXbData::Callback_CFepXb_sendSettingValuePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_sendSettingValue(__p_settingVal, &__ctx, __del, __cookie);
    }

    void end_sendSettingValue(const ::Ice::AsyncResultPtr&);
    
private:

    void sendSettingValue(const ::FepXbData::SettingValueInfo&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_sendSettingValue(const ::FepXbData::SettingValueInfo&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void sendBrief(const ::FepXbData::TduBrief& __p_briefVal)
    {
        sendBrief(__p_briefVal, 0);
    }
    void sendBrief(const ::FepXbData::TduBrief& __p_briefVal, const ::Ice::Context& __ctx)
    {
        sendBrief(__p_briefVal, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_sendBrief(const ::FepXbData::TduBrief& __p_briefVal, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return begin_sendBrief(__p_briefVal, 0, new ::IceInternal::Cpp11FnOnewayCallbackNC(__response, __exception, __sent));
    }
    ::Ice::AsyncResultPtr
    begin_sendBrief(const ::FepXbData::TduBrief& __p_briefVal, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_sendBrief(__p_briefVal, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_sendBrief(const ::FepXbData::TduBrief& __p_briefVal, const ::Ice::Context& __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return begin_sendBrief(__p_briefVal, &__ctx, new ::IceInternal::Cpp11FnOnewayCallbackNC(__response, __exception, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_sendBrief(const ::FepXbData::TduBrief& __p_briefVal, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_sendBrief(__p_briefVal, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
#endif

    ::Ice::AsyncResultPtr begin_sendBrief(const ::FepXbData::TduBrief& __p_briefVal)
    {
        return begin_sendBrief(__p_briefVal, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_sendBrief(const ::FepXbData::TduBrief& __p_briefVal, const ::Ice::Context& __ctx)
    {
        return begin_sendBrief(__p_briefVal, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_sendBrief(const ::FepXbData::TduBrief& __p_briefVal, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_sendBrief(__p_briefVal, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_sendBrief(const ::FepXbData::TduBrief& __p_briefVal, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_sendBrief(__p_briefVal, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_sendBrief(const ::FepXbData::TduBrief& __p_briefVal, const ::FepXbData::Callback_CFepXb_sendBriefPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_sendBrief(__p_briefVal, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_sendBrief(const ::FepXbData::TduBrief& __p_briefVal, const ::Ice::Context& __ctx, const ::FepXbData::Callback_CFepXb_sendBriefPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_sendBrief(__p_briefVal, &__ctx, __del, __cookie);
    }

    void end_sendBrief(const ::Ice::AsyncResultPtr&);
    
private:

    void sendBrief(const ::FepXbData::TduBrief&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_sendBrief(const ::FepXbData::TduBrief&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void sendSoe(const ::FepXbData::XbSOESeq& __p_soeSeq)
    {
        sendSoe(__p_soeSeq, 0);
    }
    void sendSoe(const ::FepXbData::XbSOESeq& __p_soeSeq, const ::Ice::Context& __ctx)
    {
        sendSoe(__p_soeSeq, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_sendSoe(const ::FepXbData::XbSOESeq& __p_soeSeq, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return begin_sendSoe(__p_soeSeq, 0, new ::IceInternal::Cpp11FnOnewayCallbackNC(__response, __exception, __sent));
    }
    ::Ice::AsyncResultPtr
    begin_sendSoe(const ::FepXbData::XbSOESeq& __p_soeSeq, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_sendSoe(__p_soeSeq, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_sendSoe(const ::FepXbData::XbSOESeq& __p_soeSeq, const ::Ice::Context& __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return begin_sendSoe(__p_soeSeq, &__ctx, new ::IceInternal::Cpp11FnOnewayCallbackNC(__response, __exception, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_sendSoe(const ::FepXbData::XbSOESeq& __p_soeSeq, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_sendSoe(__p_soeSeq, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
#endif

    ::Ice::AsyncResultPtr begin_sendSoe(const ::FepXbData::XbSOESeq& __p_soeSeq)
    {
        return begin_sendSoe(__p_soeSeq, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_sendSoe(const ::FepXbData::XbSOESeq& __p_soeSeq, const ::Ice::Context& __ctx)
    {
        return begin_sendSoe(__p_soeSeq, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_sendSoe(const ::FepXbData::XbSOESeq& __p_soeSeq, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_sendSoe(__p_soeSeq, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_sendSoe(const ::FepXbData::XbSOESeq& __p_soeSeq, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_sendSoe(__p_soeSeq, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_sendSoe(const ::FepXbData::XbSOESeq& __p_soeSeq, const ::FepXbData::Callback_CFepXb_sendSoePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_sendSoe(__p_soeSeq, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_sendSoe(const ::FepXbData::XbSOESeq& __p_soeSeq, const ::Ice::Context& __ctx, const ::FepXbData::Callback_CFepXb_sendSoePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_sendSoe(__p_soeSeq, &__ctx, __del, __cookie);
    }

    void end_sendSoe(const ::Ice::AsyncResultPtr&);
    
private:

    void sendSoe(const ::FepXbData::XbSOESeq&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_sendSoe(const ::FepXbData::XbSOESeq&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void sendDiscrete(const ::FepXbData::XbDiscreteSeq& __p_discreteSeq)
    {
        sendDiscrete(__p_discreteSeq, 0);
    }
    void sendDiscrete(const ::FepXbData::XbDiscreteSeq& __p_discreteSeq, const ::Ice::Context& __ctx)
    {
        sendDiscrete(__p_discreteSeq, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_sendDiscrete(const ::FepXbData::XbDiscreteSeq& __p_discreteSeq, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return begin_sendDiscrete(__p_discreteSeq, 0, new ::IceInternal::Cpp11FnOnewayCallbackNC(__response, __exception, __sent));
    }
    ::Ice::AsyncResultPtr
    begin_sendDiscrete(const ::FepXbData::XbDiscreteSeq& __p_discreteSeq, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_sendDiscrete(__p_discreteSeq, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_sendDiscrete(const ::FepXbData::XbDiscreteSeq& __p_discreteSeq, const ::Ice::Context& __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return begin_sendDiscrete(__p_discreteSeq, &__ctx, new ::IceInternal::Cpp11FnOnewayCallbackNC(__response, __exception, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_sendDiscrete(const ::FepXbData::XbDiscreteSeq& __p_discreteSeq, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_sendDiscrete(__p_discreteSeq, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
#endif

    ::Ice::AsyncResultPtr begin_sendDiscrete(const ::FepXbData::XbDiscreteSeq& __p_discreteSeq)
    {
        return begin_sendDiscrete(__p_discreteSeq, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_sendDiscrete(const ::FepXbData::XbDiscreteSeq& __p_discreteSeq, const ::Ice::Context& __ctx)
    {
        return begin_sendDiscrete(__p_discreteSeq, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_sendDiscrete(const ::FepXbData::XbDiscreteSeq& __p_discreteSeq, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_sendDiscrete(__p_discreteSeq, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_sendDiscrete(const ::FepXbData::XbDiscreteSeq& __p_discreteSeq, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_sendDiscrete(__p_discreteSeq, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_sendDiscrete(const ::FepXbData::XbDiscreteSeq& __p_discreteSeq, const ::FepXbData::Callback_CFepXb_sendDiscretePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_sendDiscrete(__p_discreteSeq, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_sendDiscrete(const ::FepXbData::XbDiscreteSeq& __p_discreteSeq, const ::Ice::Context& __ctx, const ::FepXbData::Callback_CFepXb_sendDiscretePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_sendDiscrete(__p_discreteSeq, &__ctx, __del, __cookie);
    }

    void end_sendDiscrete(const ::Ice::AsyncResultPtr&);
    
private:

    void sendDiscrete(const ::FepXbData::XbDiscreteSeq&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_sendDiscrete(const ::FepXbData::XbDiscreteSeq&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void sendUnitStatus(const ::FepXbData::XbUnitStatusSeq& __p_usSeq)
    {
        sendUnitStatus(__p_usSeq, 0);
    }
    void sendUnitStatus(const ::FepXbData::XbUnitStatusSeq& __p_usSeq, const ::Ice::Context& __ctx)
    {
        sendUnitStatus(__p_usSeq, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_sendUnitStatus(const ::FepXbData::XbUnitStatusSeq& __p_usSeq, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return begin_sendUnitStatus(__p_usSeq, 0, new ::IceInternal::Cpp11FnOnewayCallbackNC(__response, __exception, __sent));
    }
    ::Ice::AsyncResultPtr
    begin_sendUnitStatus(const ::FepXbData::XbUnitStatusSeq& __p_usSeq, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_sendUnitStatus(__p_usSeq, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_sendUnitStatus(const ::FepXbData::XbUnitStatusSeq& __p_usSeq, const ::Ice::Context& __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return begin_sendUnitStatus(__p_usSeq, &__ctx, new ::IceInternal::Cpp11FnOnewayCallbackNC(__response, __exception, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_sendUnitStatus(const ::FepXbData::XbUnitStatusSeq& __p_usSeq, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_sendUnitStatus(__p_usSeq, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
#endif

    ::Ice::AsyncResultPtr begin_sendUnitStatus(const ::FepXbData::XbUnitStatusSeq& __p_usSeq)
    {
        return begin_sendUnitStatus(__p_usSeq, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_sendUnitStatus(const ::FepXbData::XbUnitStatusSeq& __p_usSeq, const ::Ice::Context& __ctx)
    {
        return begin_sendUnitStatus(__p_usSeq, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_sendUnitStatus(const ::FepXbData::XbUnitStatusSeq& __p_usSeq, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_sendUnitStatus(__p_usSeq, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_sendUnitStatus(const ::FepXbData::XbUnitStatusSeq& __p_usSeq, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_sendUnitStatus(__p_usSeq, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_sendUnitStatus(const ::FepXbData::XbUnitStatusSeq& __p_usSeq, const ::FepXbData::Callback_CFepXb_sendUnitStatusPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_sendUnitStatus(__p_usSeq, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_sendUnitStatus(const ::FepXbData::XbUnitStatusSeq& __p_usSeq, const ::Ice::Context& __ctx, const ::FepXbData::Callback_CFepXb_sendUnitStatusPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_sendUnitStatus(__p_usSeq, &__ctx, __del, __cookie);
    }

    void end_sendUnitStatus(const ::Ice::AsyncResultPtr&);
    
private:

    void sendUnitStatus(const ::FepXbData::XbUnitStatusSeq&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_sendUnitStatus(const ::FepXbData::XbUnitStatusSeq&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void sendWave(const ::FepXbData::XbWave& __p_wave)
    {
        sendWave(__p_wave, 0);
    }
    void sendWave(const ::FepXbData::XbWave& __p_wave, const ::Ice::Context& __ctx)
    {
        sendWave(__p_wave, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_sendWave(const ::FepXbData::XbWave& __p_wave, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return begin_sendWave(__p_wave, 0, new ::IceInternal::Cpp11FnOnewayCallbackNC(__response, __exception, __sent));
    }
    ::Ice::AsyncResultPtr
    begin_sendWave(const ::FepXbData::XbWave& __p_wave, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_sendWave(__p_wave, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_sendWave(const ::FepXbData::XbWave& __p_wave, const ::Ice::Context& __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return begin_sendWave(__p_wave, &__ctx, new ::IceInternal::Cpp11FnOnewayCallbackNC(__response, __exception, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_sendWave(const ::FepXbData::XbWave& __p_wave, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_sendWave(__p_wave, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
#endif

    ::Ice::AsyncResultPtr begin_sendWave(const ::FepXbData::XbWave& __p_wave)
    {
        return begin_sendWave(__p_wave, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_sendWave(const ::FepXbData::XbWave& __p_wave, const ::Ice::Context& __ctx)
    {
        return begin_sendWave(__p_wave, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_sendWave(const ::FepXbData::XbWave& __p_wave, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_sendWave(__p_wave, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_sendWave(const ::FepXbData::XbWave& __p_wave, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_sendWave(__p_wave, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_sendWave(const ::FepXbData::XbWave& __p_wave, const ::FepXbData::Callback_CFepXb_sendWavePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_sendWave(__p_wave, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_sendWave(const ::FepXbData::XbWave& __p_wave, const ::Ice::Context& __ctx, const ::FepXbData::Callback_CFepXb_sendWavePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_sendWave(__p_wave, &__ctx, __del, __cookie);
    }

    void end_sendWave(const ::Ice::AsyncResultPtr&);
    
private:

    void sendWave(const ::FepXbData::XbWave&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_sendWave(const ::FepXbData::XbWave&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    
    ::IceInternal::ProxyHandle<CFepXb> ice_context(const ::Ice::Context& __context) const
    {
        return dynamic_cast<CFepXb*>(::IceProxy::Ice::Object::ice_context(__context).get());
    }
    
    ::IceInternal::ProxyHandle<CFepXb> ice_adapterId(const ::std::string& __id) const
    {
        return dynamic_cast<CFepXb*>(::IceProxy::Ice::Object::ice_adapterId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<CFepXb> ice_endpoints(const ::Ice::EndpointSeq& __endpoints) const
    {
        return dynamic_cast<CFepXb*>(::IceProxy::Ice::Object::ice_endpoints(__endpoints).get());
    }
    
    ::IceInternal::ProxyHandle<CFepXb> ice_locatorCacheTimeout(int __timeout) const
    {
        return dynamic_cast<CFepXb*>(::IceProxy::Ice::Object::ice_locatorCacheTimeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<CFepXb> ice_connectionCached(bool __cached) const
    {
        return dynamic_cast<CFepXb*>(::IceProxy::Ice::Object::ice_connectionCached(__cached).get());
    }
    
    ::IceInternal::ProxyHandle<CFepXb> ice_endpointSelection(::Ice::EndpointSelectionType __est) const
    {
        return dynamic_cast<CFepXb*>(::IceProxy::Ice::Object::ice_endpointSelection(__est).get());
    }
    
    ::IceInternal::ProxyHandle<CFepXb> ice_secure(bool __secure) const
    {
        return dynamic_cast<CFepXb*>(::IceProxy::Ice::Object::ice_secure(__secure).get());
    }
    
    ::IceInternal::ProxyHandle<CFepXb> ice_preferSecure(bool __preferSecure) const
    {
        return dynamic_cast<CFepXb*>(::IceProxy::Ice::Object::ice_preferSecure(__preferSecure).get());
    }
    
    ::IceInternal::ProxyHandle<CFepXb> ice_router(const ::Ice::RouterPrx& __router) const
    {
        return dynamic_cast<CFepXb*>(::IceProxy::Ice::Object::ice_router(__router).get());
    }
    
    ::IceInternal::ProxyHandle<CFepXb> ice_locator(const ::Ice::LocatorPrx& __locator) const
    {
        return dynamic_cast<CFepXb*>(::IceProxy::Ice::Object::ice_locator(__locator).get());
    }
    
    ::IceInternal::ProxyHandle<CFepXb> ice_collocationOptimized(bool __co) const
    {
        return dynamic_cast<CFepXb*>(::IceProxy::Ice::Object::ice_collocationOptimized(__co).get());
    }
    
    ::IceInternal::ProxyHandle<CFepXb> ice_invocationTimeout(int __timeout) const
    {
        return dynamic_cast<CFepXb*>(::IceProxy::Ice::Object::ice_invocationTimeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<CFepXb> ice_twoway() const
    {
        return dynamic_cast<CFepXb*>(::IceProxy::Ice::Object::ice_twoway().get());
    }
    
    ::IceInternal::ProxyHandle<CFepXb> ice_oneway() const
    {
        return dynamic_cast<CFepXb*>(::IceProxy::Ice::Object::ice_oneway().get());
    }
    
    ::IceInternal::ProxyHandle<CFepXb> ice_batchOneway() const
    {
        return dynamic_cast<CFepXb*>(::IceProxy::Ice::Object::ice_batchOneway().get());
    }
    
    ::IceInternal::ProxyHandle<CFepXb> ice_datagram() const
    {
        return dynamic_cast<CFepXb*>(::IceProxy::Ice::Object::ice_datagram().get());
    }
    
    ::IceInternal::ProxyHandle<CFepXb> ice_batchDatagram() const
    {
        return dynamic_cast<CFepXb*>(::IceProxy::Ice::Object::ice_batchDatagram().get());
    }
    
    ::IceInternal::ProxyHandle<CFepXb> ice_compress(bool __compress) const
    {
        return dynamic_cast<CFepXb*>(::IceProxy::Ice::Object::ice_compress(__compress).get());
    }
    
    ::IceInternal::ProxyHandle<CFepXb> ice_timeout(int __timeout) const
    {
        return dynamic_cast<CFepXb*>(::IceProxy::Ice::Object::ice_timeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<CFepXb> ice_connectionId(const ::std::string& __id) const
    {
        return dynamic_cast<CFepXb*>(::IceProxy::Ice::Object::ice_connectionId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<CFepXb> ice_encodingVersion(const ::Ice::EncodingVersion& __v) const
    {
        return dynamic_cast<CFepXb*>(::IceProxy::Ice::Object::ice_encodingVersion(__v).get());
    }
    
    static const ::std::string& ice_staticId();

private: 
    virtual ::IceProxy::Ice::Object* __newInstance() const;
};

}

}

namespace FepXbData
{

class CFepXb : virtual public ::Ice::Object
{
public:

    typedef CFepXbPrx ProxyType;
    typedef CFepXbPtr PointerType;

    virtual bool ice_isA(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) const;
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& = ::Ice::Current()) const;
    virtual const ::std::string& ice_id(const ::Ice::Current& = ::Ice::Current()) const;
    static const ::std::string& ice_staticId();

    virtual void sendSettingValue(const ::FepXbData::SettingValueInfo&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___sendSettingValue(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void sendBrief(const ::FepXbData::TduBrief&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___sendBrief(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void sendSoe(const ::FepXbData::XbSOESeq&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___sendSoe(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void sendDiscrete(const ::FepXbData::XbDiscreteSeq&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___sendDiscrete(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void sendUnitStatus(const ::FepXbData::XbUnitStatusSeq&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___sendUnitStatus(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void sendWave(const ::FepXbData::XbWave&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___sendWave(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Ice::DispatchStatus __dispatch(::IceInternal::Incoming&, const ::Ice::Current&);

protected:
    virtual void __writeImpl(::IceInternal::BasicStream*) const;
    virtual void __readImpl(::IceInternal::BasicStream*);
    using ::Ice::Object::__writeImpl;
    using ::Ice::Object::__readImpl;
};

inline bool operator==(const CFepXb& l, const CFepXb& r)
{
    return static_cast<const ::Ice::Object&>(l) == static_cast<const ::Ice::Object&>(r);
}

inline bool operator<(const CFepXb& l, const CFepXb& r)
{
    return static_cast<const ::Ice::Object&>(l) < static_cast<const ::Ice::Object&>(r);
}

}

namespace FepXbData
{

template<class T>
class CallbackNC_CFepXb_sendSettingValue : public Callback_CFepXb_sendSettingValue_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_CFepXb_sendSettingValue(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

template<class T> Callback_CFepXb_sendSettingValuePtr
newCallback_CFepXb_sendSettingValue(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_CFepXb_sendSettingValue<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_CFepXb_sendSettingValuePtr
newCallback_CFepXb_sendSettingValue(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_CFepXb_sendSettingValue<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_CFepXb_sendSettingValuePtr
newCallback_CFepXb_sendSettingValue(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_CFepXb_sendSettingValue<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_CFepXb_sendSettingValuePtr
newCallback_CFepXb_sendSettingValue(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_CFepXb_sendSettingValue<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_CFepXb_sendSettingValue : public Callback_CFepXb_sendSettingValue_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_CFepXb_sendSettingValue(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

template<class T, typename CT> Callback_CFepXb_sendSettingValuePtr
newCallback_CFepXb_sendSettingValue(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_CFepXb_sendSettingValue<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_CFepXb_sendSettingValuePtr
newCallback_CFepXb_sendSettingValue(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_CFepXb_sendSettingValue<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_CFepXb_sendSettingValuePtr
newCallback_CFepXb_sendSettingValue(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_CFepXb_sendSettingValue<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_CFepXb_sendSettingValuePtr
newCallback_CFepXb_sendSettingValue(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_CFepXb_sendSettingValue<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_CFepXb_sendBrief : public Callback_CFepXb_sendBrief_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_CFepXb_sendBrief(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

template<class T> Callback_CFepXb_sendBriefPtr
newCallback_CFepXb_sendBrief(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_CFepXb_sendBrief<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_CFepXb_sendBriefPtr
newCallback_CFepXb_sendBrief(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_CFepXb_sendBrief<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_CFepXb_sendBriefPtr
newCallback_CFepXb_sendBrief(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_CFepXb_sendBrief<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_CFepXb_sendBriefPtr
newCallback_CFepXb_sendBrief(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_CFepXb_sendBrief<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_CFepXb_sendBrief : public Callback_CFepXb_sendBrief_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_CFepXb_sendBrief(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

template<class T, typename CT> Callback_CFepXb_sendBriefPtr
newCallback_CFepXb_sendBrief(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_CFepXb_sendBrief<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_CFepXb_sendBriefPtr
newCallback_CFepXb_sendBrief(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_CFepXb_sendBrief<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_CFepXb_sendBriefPtr
newCallback_CFepXb_sendBrief(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_CFepXb_sendBrief<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_CFepXb_sendBriefPtr
newCallback_CFepXb_sendBrief(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_CFepXb_sendBrief<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_CFepXb_sendSoe : public Callback_CFepXb_sendSoe_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_CFepXb_sendSoe(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

template<class T> Callback_CFepXb_sendSoePtr
newCallback_CFepXb_sendSoe(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_CFepXb_sendSoe<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_CFepXb_sendSoePtr
newCallback_CFepXb_sendSoe(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_CFepXb_sendSoe<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_CFepXb_sendSoePtr
newCallback_CFepXb_sendSoe(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_CFepXb_sendSoe<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_CFepXb_sendSoePtr
newCallback_CFepXb_sendSoe(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_CFepXb_sendSoe<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_CFepXb_sendSoe : public Callback_CFepXb_sendSoe_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_CFepXb_sendSoe(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

template<class T, typename CT> Callback_CFepXb_sendSoePtr
newCallback_CFepXb_sendSoe(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_CFepXb_sendSoe<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_CFepXb_sendSoePtr
newCallback_CFepXb_sendSoe(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_CFepXb_sendSoe<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_CFepXb_sendSoePtr
newCallback_CFepXb_sendSoe(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_CFepXb_sendSoe<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_CFepXb_sendSoePtr
newCallback_CFepXb_sendSoe(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_CFepXb_sendSoe<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_CFepXb_sendDiscrete : public Callback_CFepXb_sendDiscrete_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_CFepXb_sendDiscrete(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

template<class T> Callback_CFepXb_sendDiscretePtr
newCallback_CFepXb_sendDiscrete(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_CFepXb_sendDiscrete<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_CFepXb_sendDiscretePtr
newCallback_CFepXb_sendDiscrete(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_CFepXb_sendDiscrete<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_CFepXb_sendDiscretePtr
newCallback_CFepXb_sendDiscrete(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_CFepXb_sendDiscrete<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_CFepXb_sendDiscretePtr
newCallback_CFepXb_sendDiscrete(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_CFepXb_sendDiscrete<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_CFepXb_sendDiscrete : public Callback_CFepXb_sendDiscrete_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_CFepXb_sendDiscrete(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

template<class T, typename CT> Callback_CFepXb_sendDiscretePtr
newCallback_CFepXb_sendDiscrete(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_CFepXb_sendDiscrete<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_CFepXb_sendDiscretePtr
newCallback_CFepXb_sendDiscrete(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_CFepXb_sendDiscrete<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_CFepXb_sendDiscretePtr
newCallback_CFepXb_sendDiscrete(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_CFepXb_sendDiscrete<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_CFepXb_sendDiscretePtr
newCallback_CFepXb_sendDiscrete(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_CFepXb_sendDiscrete<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_CFepXb_sendUnitStatus : public Callback_CFepXb_sendUnitStatus_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_CFepXb_sendUnitStatus(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

template<class T> Callback_CFepXb_sendUnitStatusPtr
newCallback_CFepXb_sendUnitStatus(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_CFepXb_sendUnitStatus<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_CFepXb_sendUnitStatusPtr
newCallback_CFepXb_sendUnitStatus(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_CFepXb_sendUnitStatus<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_CFepXb_sendUnitStatusPtr
newCallback_CFepXb_sendUnitStatus(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_CFepXb_sendUnitStatus<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_CFepXb_sendUnitStatusPtr
newCallback_CFepXb_sendUnitStatus(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_CFepXb_sendUnitStatus<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_CFepXb_sendUnitStatus : public Callback_CFepXb_sendUnitStatus_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_CFepXb_sendUnitStatus(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

template<class T, typename CT> Callback_CFepXb_sendUnitStatusPtr
newCallback_CFepXb_sendUnitStatus(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_CFepXb_sendUnitStatus<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_CFepXb_sendUnitStatusPtr
newCallback_CFepXb_sendUnitStatus(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_CFepXb_sendUnitStatus<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_CFepXb_sendUnitStatusPtr
newCallback_CFepXb_sendUnitStatus(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_CFepXb_sendUnitStatus<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_CFepXb_sendUnitStatusPtr
newCallback_CFepXb_sendUnitStatus(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_CFepXb_sendUnitStatus<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_CFepXb_sendWave : public Callback_CFepXb_sendWave_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_CFepXb_sendWave(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

template<class T> Callback_CFepXb_sendWavePtr
newCallback_CFepXb_sendWave(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_CFepXb_sendWave<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_CFepXb_sendWavePtr
newCallback_CFepXb_sendWave(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_CFepXb_sendWave<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_CFepXb_sendWavePtr
newCallback_CFepXb_sendWave(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_CFepXb_sendWave<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_CFepXb_sendWavePtr
newCallback_CFepXb_sendWave(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_CFepXb_sendWave<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_CFepXb_sendWave : public Callback_CFepXb_sendWave_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_CFepXb_sendWave(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

template<class T, typename CT> Callback_CFepXb_sendWavePtr
newCallback_CFepXb_sendWave(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_CFepXb_sendWave<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_CFepXb_sendWavePtr
newCallback_CFepXb_sendWave(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_CFepXb_sendWave<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_CFepXb_sendWavePtr
newCallback_CFepXb_sendWave(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_CFepXb_sendWave<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_CFepXb_sendWavePtr
newCallback_CFepXb_sendWave(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_CFepXb_sendWave<T, CT>(instance, 0, excb, sentcb);
}

}

#include <IceUtil/PopDisableWarnings.h>
#endif
