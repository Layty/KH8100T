// **********************************************************************
//
// Copyright (c) 2003-2017 ZeroC, Inc. All rights reserved.
//
// This copy of Ice is licensed to you under the terms described in the
// ICE_LICENSE file included in this distribution.
//
// **********************************************************************
//
// Ice version 3.6.4
//
// <auto-generated>
//
// Generated from file `SettingValue.ice'
//
// Warning: do not edit this file.
//
// </auto-generated>
//

#include <SettingValue.h>
#include <IceUtil/PushDisableWarnings.h>
#include <Ice/LocalException.h>
#include <Ice/ObjectFactory.h>
#include <Ice/Outgoing.h>
#include <Ice/OutgoingAsync.h>
#include <Ice/BasicStream.h>
#include <IceUtil/Iterator.h>
#include <IceUtil/PopDisableWarnings.h>

#ifndef ICE_IGNORE_VERSION
#   if ICE_INT_VERSION / 100 != 306
#       error Ice version mismatch!
#   endif
#   if ICE_INT_VERSION % 100 > 50
#       error Beta header file detected
#   endif
#   if ICE_INT_VERSION % 100 < 4
#       error Ice patch level mismatch!
#   endif
#endif

#ifndef _P_WIN
    class CEncodeLock
    {
    public:
        CEncodeLock()
        {
            ::pthread_mutex_init(&m_sect,NULL);
        }
        ~ CEncodeLock()
        {
            ::pthread_mutex_destroy(&m_sect);
        }
        void __inline Lock()
        {
            ::pthread_mutex_lock(&m_sect);
        }
        void __inline UnLock()
        {
            ::pthread_mutex_unlock(&m_sect);
        }
    private:
        pthread_mutex_t  m_sect;
    };

    CEncodeLock encode_lock;
#endif

std::string gbk_2_utf8(const std::string& strGBK)
{
    std::string strOutUTF8 = "";

    #ifdef _P_WIN
        WCHAR *str1;
        int n = MultiByteToWideChar(CP_ACP,0,strGBK.c_str(),-1,NULL,0);
        str1 = new WCHAR[n];
        MultiByteToWideChar(CP_ACP,0,strGBK.c_str(),-1,str1,n);
        n = WideCharToMultiByte(CP_UTF8,0,str1,-1,NULL,0,NULL,NULL);
        char *str2 = new char[n];
        WideCharToMultiByte(CP_UTF8,0,str1,-1,str2,n,NULL,NULL);
        strOutUTF8 = str2;
        delete []str1;
        delete []str2;
    #else
        if(0 == strlen(strGBK.c_str()))
        {
            //printf("warnning ---gbk_2_utf8 ：empty srcstr\n");
            return strGBK;
        }
        if(2 == strGBK.length())
        {
            if (0x0D == strGBK.at(0) && 0x0A == strGBK.at(1))
            {
                //printf("warnning ---gbk_2_utf8 ：wrwn,not need convert\n");
                return strGBK;

            }
        }
        std::string curLocale = setlocale(LC_ALL,NULL);

        encode_lock.Lock();
        //首先先将gbk编码转换为unicode编码
        if(NULL==setlocale(LC_ALL,"zh_CN.gbk"))//设置转换为unicode前的码,当前为gbk编码
        {
            //printf("gbk_2_utf8 ：setlocale zh_CN.gbk err!:%d\n",errno);
            encode_lock.UnLock();
            return strGBK;
        }
        int unicodelen=mbstowcs(NULL,strGBK.c_str(),0);//计算转换后的长度
        if(unicodelen<=0)
        {
            //printf("gbk_2_utf8 ：unicodelen<=0!\n");
            setlocale(LC_ALL,curLocale.c_str());
            encode_lock.UnLock();
            return strGBK;
        }
        wchar_t *unicodestr= new(std::nothrow) wchar_t[unicodelen+1];
        if (NULL == unicodestr)
        {
            //printf("gbk_2_utf8 ：new unicodestr err!\n");
            setlocale(LC_ALL,curLocale.c_str());
            encode_lock.UnLock();
            return strGBK;
        }
        wmemset(unicodestr,0,unicodelen+1);
        mbstowcs(unicodestr,strGBK.c_str(),strlen(strGBK.c_str()));//将gbk转换为unicode

        //将unicode编码转换为utf8编码
        if(NULL==setlocale(LC_ALL,"zh_CN.utf8"))//设置unicode转换后的码,当前为utf8
        {
           // printf("gbk_2_utf8 ：setlocale zh_CN.utf8 err！:%d\n",errno);
            delete []unicodestr;
            setlocale(LC_ALL,curLocale.c_str());
            encode_lock.UnLock();
            return strGBK;
        }
        int utflen=wcstombs(NULL,unicodestr,0);//计算转换后的长度
        if(utflen<=0)
        {
           // printf("gbk_2_utf8 ：utflen<=0!\n");
            delete []unicodestr;
            setlocale(LC_ALL,curLocale.c_str());
            encode_lock.UnLock();
            return strGBK;
        }
        char *utfstr=new(std::nothrow) char[utflen+1];
        if (NULL == utfstr)
        {
            //printf("gbk_2_utf8 ：new utfstr err!\n");
            delete []unicodestr;
            setlocale(LC_ALL,curLocale.c_str());
            encode_lock.UnLock();
            return strGBK;
        }
        memset(utfstr,0,utflen+1);
        wcstombs(utfstr,unicodestr,utflen);
        utfstr[utflen]=0;//添加结束符

        strOutUTF8 = utfstr;

        delete []unicodestr;
        delete []utfstr;
        setlocale(LC_ALL,curLocale.c_str());
        encode_lock.UnLock();
    #endif

    return strOutUTF8;
}

std::string utf8_2_gbk(const std::string& strUTF8)
{
    std::string strOutGBK;

    #ifdef _P_WIN
        int len = MultiByteToWideChar(CP_UTF8,0,strUTF8.c_str(),-1,NULL,0);
        LPWSTR wszGBK = new WCHAR[len+1];
        memset(wszGBK,0,len*2+2);
        MultiByteToWideChar(CP_UTF8,0,(const char*)strUTF8.c_str(),-1,wszGBK,len);
        len = WideCharToMultiByte(CP_ACP,0,wszGBK,-1,NULL,0,NULL,NULL);
        char *szGBK = new char[len+1];
        memset(szGBK,0,len+1);
        WideCharToMultiByte(CP_ACP,0,wszGBK,-1,szGBK,len,NULL,NULL);
        strOutGBK = szGBK;
        delete []szGBK;
        delete []wszGBK;
    #else
        if(0 == strlen(strUTF8.c_str()))
        {
            //printf("warnning ---utf8_2_gbk ：empty srcstr\n");
            return strUTF8;
        }
        if(2 == strUTF8.length())
        {
            if (0x0D == strUTF8.at(0) && 0x0A == strUTF8.at(1))
            {
                //printf("warnning ---utf8_2_gbk ：wrwn,not need convert\n");
                return strUTF8;
            }
        }

        std::string curLocale = setlocale(LC_ALL,NULL);

        encode_lock.Lock();
        //首先先将utf8编码转换为unicode编码
        if(NULL==setlocale(LC_ALL,"zh_CN.utf8"))//设置转换为unicode前的码,当前为utf8编码
        {
            //printf("utf8_2_gbk ：setlocale zh_CN.utf8 err!:%d\n",errno);
            encode_lock.UnLock();
            return strUTF8;
        }
        int unicodelen=mbstowcs(NULL,strUTF8.c_str(),0);//计算转换后的长度
        if(unicodelen<=0)
        {
            //printf("utf8_2_gbk ：unicodelen<=0!\n");
            setlocale(LC_ALL,curLocale.c_str());
            encode_lock.UnLock();
            return strUTF8;
        }
        wchar_t *unicodestr= new(std::nothrow) wchar_t[unicodelen+1];
        if (NULL == unicodestr)
        {
            //printf("utf8_2_gbk ：new unicodestr err!\n");
            setlocale(LC_ALL,curLocale.c_str());
            encode_lock.UnLock();
            return strUTF8;
        }
        wmemset(unicodestr,0,unicodelen+1);
        mbstowcs(unicodestr,strUTF8.c_str(),strlen(strUTF8.c_str()));//将utf8转换为unicode

        //将unicode编码转换为gbk编码
        if(NULL==setlocale(LC_ALL,"zh_CN.gbk"))//设置unicode转换后的码,当前为gbk
        {
            //printf("utf8_2_gbk ：setlocale zh_CN.gbk err！:%d\n",errno);
            delete []unicodestr;
            setlocale(LC_ALL,curLocale.c_str());
            encode_lock.UnLock();
            return strUTF8;
        }
        int gbklen=wcstombs(NULL,unicodestr,0);//计算转换后的长度
        if(gbklen<=0)
        {
            //printf("utf8_2_gbk ：gbklen<=0!\n");
            delete []unicodestr;
            setlocale(LC_ALL,curLocale.c_str());
            encode_lock.UnLock();
            return strUTF8;
        }
        char *gbkstr=new(std::nothrow) char[gbklen+1];
        if (NULL == gbkstr)
        {
            //printf("utf8_2_gbk ：new utfstr err!\n");
            delete []unicodestr;
            setlocale(LC_ALL,curLocale.c_str());
            encode_lock.UnLock();
            return strUTF8;
        }
        memset(gbkstr,0,gbklen+1);
        wcstombs(gbkstr,unicodestr,gbklen);
        gbkstr[gbklen]=0;//添加结束符

        strOutGBK = gbkstr;

        delete []unicodestr;
        delete []gbkstr;
        setlocale(LC_ALL,curLocale.c_str());
        encode_lock.UnLock();
    #endif

    return strOutGBK;
}

namespace
{

const ::std::string __SettingValue__CSettingValueApp__readValueReply_name = "readValueReply";

const ::std::string __SettingValue__CSettingValueApp__writeValueReply_name = "writeValueReply";

const ::std::string __SettingValue__CSettingValueFep__readValue_name = "readValue";

const ::std::string __SettingValue__CSettingValueFep__writeValue_name = "writeValue";

}

namespace Ice
{
}
::IceProxy::Ice::Object* ::IceProxy::SettingValue::upCast(::IceProxy::SettingValue::CSettingValueApp* p) { return p; }

void
::IceProxy::SettingValue::__read(::IceInternal::BasicStream* __is, ::IceInternal::ProxyHandle< ::IceProxy::SettingValue::CSettingValueApp>& v)
{
    ::Ice::ObjectPrx proxy;
    __is->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new ::IceProxy::SettingValue::CSettingValueApp;
        v->__copyFrom(proxy);
    }
}

void
IceProxy::SettingValue::CSettingValueApp::readValueReply(const ::SettingValue::SettingValueInfo& __p_settingVal, bool __p_flag, const ::std::string& __p_tip, const ::Ice::Context* __ctx)
{
    ::IceInternal::Outgoing __og(this, __SettingValue__CSettingValueApp__readValueReply_name, ::Ice::Normal, __ctx);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_settingVal);
        __os->write(__p_flag);
        __os->write(__p_tip);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    __invoke(__og);
}

::Ice::AsyncResultPtr
IceProxy::SettingValue::CSettingValueApp::begin_readValueReply(const ::SettingValue::SettingValueInfo& __p_settingVal, bool __p_flag, const ::std::string& __p_tip, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __SettingValue__CSettingValueApp__readValueReply_name, __del, __cookie);
    try
    {
        __result->prepare(__SettingValue__CSettingValueApp__readValueReply_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_settingVal);
        __os->write(__p_flag);
        __os->write(__p_tip);
        __result->endWriteParams();
        __result->invoke();
    }
    catch(const ::Ice::Exception& __ex)
    {
        __result->abort(__ex);
    }
    return __result;
}

void
IceProxy::SettingValue::CSettingValueApp::end_readValueReply(const ::Ice::AsyncResultPtr& __result)
{
    __end(__result, __SettingValue__CSettingValueApp__readValueReply_name);
}

void
IceProxy::SettingValue::CSettingValueApp::writeValueReply(const ::std::string& __p_deviceId, bool __p_flag, const ::std::string& __p_tip, const ::Ice::Context* __ctx)
{
    ::IceInternal::Outgoing __og(this, __SettingValue__CSettingValueApp__writeValueReply_name, ::Ice::Normal, __ctx);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_deviceId);
        __os->write(__p_flag);
        __os->write(__p_tip);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    __invoke(__og);
}

::Ice::AsyncResultPtr
IceProxy::SettingValue::CSettingValueApp::begin_writeValueReply(const ::std::string& __p_deviceId, bool __p_flag, const ::std::string& __p_tip, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __SettingValue__CSettingValueApp__writeValueReply_name, __del, __cookie);
    try
    {
        __result->prepare(__SettingValue__CSettingValueApp__writeValueReply_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_deviceId);
        __os->write(__p_flag);
        __os->write(__p_tip);
        __result->endWriteParams();
        __result->invoke();
    }
    catch(const ::Ice::Exception& __ex)
    {
        __result->abort(__ex);
    }
    return __result;
}

void
IceProxy::SettingValue::CSettingValueApp::end_writeValueReply(const ::Ice::AsyncResultPtr& __result)
{
    __end(__result, __SettingValue__CSettingValueApp__writeValueReply_name);
}

const ::std::string&
IceProxy::SettingValue::CSettingValueApp::ice_staticId()
{
    return ::SettingValue::CSettingValueApp::ice_staticId();
}

::IceProxy::Ice::Object*
IceProxy::SettingValue::CSettingValueApp::__newInstance() const
{
    return new CSettingValueApp;
}
::IceProxy::Ice::Object* ::IceProxy::SettingValue::upCast(::IceProxy::SettingValue::CSettingValueFep* p) { return p; }

void
::IceProxy::SettingValue::__read(::IceInternal::BasicStream* __is, ::IceInternal::ProxyHandle< ::IceProxy::SettingValue::CSettingValueFep>& v)
{
    ::Ice::ObjectPrx proxy;
    __is->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new ::IceProxy::SettingValue::CSettingValueFep;
        v->__copyFrom(proxy);
    }
}

void
IceProxy::SettingValue::CSettingValueFep::readValue(const ::std::string& __p_deviceId, const ::Ice::Context* __ctx)
{
    ::IceInternal::Outgoing __og(this, __SettingValue__CSettingValueFep__readValue_name, ::Ice::Normal, __ctx);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_deviceId);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    __invoke(__og);
}

::Ice::AsyncResultPtr
IceProxy::SettingValue::CSettingValueFep::begin_readValue(const ::std::string& __p_deviceId, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __SettingValue__CSettingValueFep__readValue_name, __del, __cookie);
    try
    {
        __result->prepare(__SettingValue__CSettingValueFep__readValue_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_deviceId);
        __result->endWriteParams();
        __result->invoke();
    }
    catch(const ::Ice::Exception& __ex)
    {
        __result->abort(__ex);
    }
    return __result;
}

void
IceProxy::SettingValue::CSettingValueFep::end_readValue(const ::Ice::AsyncResultPtr& __result)
{
    __end(__result, __SettingValue__CSettingValueFep__readValue_name);
}

void
IceProxy::SettingValue::CSettingValueFep::writeValue(const ::SettingValue::SettingValueInfo& __p_settingVal, const ::Ice::Context* __ctx)
{
    ::IceInternal::Outgoing __og(this, __SettingValue__CSettingValueFep__writeValue_name, ::Ice::Normal, __ctx);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_settingVal);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    __invoke(__og);
}

::Ice::AsyncResultPtr
IceProxy::SettingValue::CSettingValueFep::begin_writeValue(const ::SettingValue::SettingValueInfo& __p_settingVal, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __SettingValue__CSettingValueFep__writeValue_name, __del, __cookie);
    try
    {
        __result->prepare(__SettingValue__CSettingValueFep__writeValue_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_settingVal);
        __result->endWriteParams();
        __result->invoke();
    }
    catch(const ::Ice::Exception& __ex)
    {
        __result->abort(__ex);
    }
    return __result;
}

void
IceProxy::SettingValue::CSettingValueFep::end_writeValue(const ::Ice::AsyncResultPtr& __result)
{
    __end(__result, __SettingValue__CSettingValueFep__writeValue_name);
}

const ::std::string&
IceProxy::SettingValue::CSettingValueFep::ice_staticId()
{
    return ::SettingValue::CSettingValueFep::ice_staticId();
}

::IceProxy::Ice::Object*
IceProxy::SettingValue::CSettingValueFep::__newInstance() const
{
    return new CSettingValueFep;
}

::Ice::Object* SettingValue::upCast(::SettingValue::CSettingValueApp* p) { return p; }

namespace
{
const ::std::string __SettingValue__CSettingValueApp_ids[2] =
{
    "::Ice::Object",
    "::SettingValue::CSettingValueApp"
};

}

bool
SettingValue::CSettingValueApp::ice_isA(const ::std::string& _s, const ::Ice::Current&) const
{
    return ::std::binary_search(__SettingValue__CSettingValueApp_ids, __SettingValue__CSettingValueApp_ids + 2, _s);
}

::std::vector< ::std::string>
SettingValue::CSettingValueApp::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&__SettingValue__CSettingValueApp_ids[0], &__SettingValue__CSettingValueApp_ids[2]);
}

const ::std::string&
SettingValue::CSettingValueApp::ice_id(const ::Ice::Current&) const
{
    return __SettingValue__CSettingValueApp_ids[1];
}

const ::std::string&
SettingValue::CSettingValueApp::ice_staticId()
{
#ifdef ICE_HAS_THREAD_SAFE_LOCAL_STATIC
    static const ::std::string typeId = "::SettingValue::CSettingValueApp";
    return typeId;
#else
    return __SettingValue__CSettingValueApp_ids[1];
#endif
}

::Ice::DispatchStatus
SettingValue::CSettingValueApp::___readValueReply(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::SettingValue::SettingValueInfo __p_settingVal;
    bool __p_flag;
    ::std::string __p_tip;
    __is->read(__p_settingVal);
    __is->read(__p_flag);
    __is->read(__p_tip);
    __inS.endReadParams();
    readValueReply(__p_settingVal, __p_flag, __p_tip, __current);
    __inS.__writeEmptyParams();
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
SettingValue::CSettingValueApp::___writeValueReply(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::std::string __p_deviceId;
    bool __p_flag;
    ::std::string __p_tip;
    __is->read(__p_deviceId);
    __is->read(__p_flag);
    __is->read(__p_tip);
    __inS.endReadParams();
    writeValueReply(__p_deviceId, __p_flag, __p_tip, __current);
    __inS.__writeEmptyParams();
    return ::Ice::DispatchOK;
}

namespace
{
const ::std::string __SettingValue__CSettingValueApp_all[] =
{
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping",
    "readValueReply",
    "writeValueReply"
};

}

::Ice::DispatchStatus
SettingValue::CSettingValueApp::__dispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair< const ::std::string*, const ::std::string*> r = ::std::equal_range(__SettingValue__CSettingValueApp_all, __SettingValue__CSettingValueApp_all + 6, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - __SettingValue__CSettingValueApp_all)
    {
        case 0:
        {
            return ___ice_id(in, current);
        }
        case 1:
        {
            return ___ice_ids(in, current);
        }
        case 2:
        {
            return ___ice_isA(in, current);
        }
        case 3:
        {
            return ___ice_ping(in, current);
        }
        case 4:
        {
            return ___readValueReply(in, current);
        }
        case 5:
        {
            return ___writeValueReply(in, current);
        }
    }

    assert(false);
    throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
}

void
SettingValue::CSettingValueApp::__writeImpl(::IceInternal::BasicStream* __os) const
{
    __os->startWriteSlice(ice_staticId(), -1, true);
    __os->endWriteSlice();
}

void
SettingValue::CSettingValueApp::__readImpl(::IceInternal::BasicStream* __is)
{
    __is->startReadSlice();
    __is->endReadSlice();
}

void 
SettingValue::__patch(CSettingValueAppPtr& handle, const ::Ice::ObjectPtr& v)
{
    handle = ::SettingValue::CSettingValueAppPtr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(::SettingValue::CSettingValueApp::ice_staticId(), v);
    }
}

::Ice::Object* SettingValue::upCast(::SettingValue::CSettingValueFep* p) { return p; }

namespace
{
const ::std::string __SettingValue__CSettingValueFep_ids[2] =
{
    "::Ice::Object",
    "::SettingValue::CSettingValueFep"
};

}

bool
SettingValue::CSettingValueFep::ice_isA(const ::std::string& _s, const ::Ice::Current&) const
{
    return ::std::binary_search(__SettingValue__CSettingValueFep_ids, __SettingValue__CSettingValueFep_ids + 2, _s);
}

::std::vector< ::std::string>
SettingValue::CSettingValueFep::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&__SettingValue__CSettingValueFep_ids[0], &__SettingValue__CSettingValueFep_ids[2]);
}

const ::std::string&
SettingValue::CSettingValueFep::ice_id(const ::Ice::Current&) const
{
    return __SettingValue__CSettingValueFep_ids[1];
}

const ::std::string&
SettingValue::CSettingValueFep::ice_staticId()
{
#ifdef ICE_HAS_THREAD_SAFE_LOCAL_STATIC
    static const ::std::string typeId = "::SettingValue::CSettingValueFep";
    return typeId;
#else
    return __SettingValue__CSettingValueFep_ids[1];
#endif
}

::Ice::DispatchStatus
SettingValue::CSettingValueFep::___readValue(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::std::string __p_deviceId;
    __is->read(__p_deviceId);
    __inS.endReadParams();
    readValue(__p_deviceId, __current);
    __inS.__writeEmptyParams();
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
SettingValue::CSettingValueFep::___writeValue(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::SettingValue::SettingValueInfo __p_settingVal;
    __is->read(__p_settingVal);
    __inS.endReadParams();
    writeValue(__p_settingVal, __current);
    __inS.__writeEmptyParams();
    return ::Ice::DispatchOK;
}

namespace
{
const ::std::string __SettingValue__CSettingValueFep_all[] =
{
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping",
    "readValue",
    "writeValue"
};

}

::Ice::DispatchStatus
SettingValue::CSettingValueFep::__dispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair< const ::std::string*, const ::std::string*> r = ::std::equal_range(__SettingValue__CSettingValueFep_all, __SettingValue__CSettingValueFep_all + 6, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - __SettingValue__CSettingValueFep_all)
    {
        case 0:
        {
            return ___ice_id(in, current);
        }
        case 1:
        {
            return ___ice_ids(in, current);
        }
        case 2:
        {
            return ___ice_isA(in, current);
        }
        case 3:
        {
            return ___ice_ping(in, current);
        }
        case 4:
        {
            return ___readValue(in, current);
        }
        case 5:
        {
            return ___writeValue(in, current);
        }
    }

    assert(false);
    throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
}

void
SettingValue::CSettingValueFep::__writeImpl(::IceInternal::BasicStream* __os) const
{
    __os->startWriteSlice(ice_staticId(), -1, true);
    __os->endWriteSlice();
}

void
SettingValue::CSettingValueFep::__readImpl(::IceInternal::BasicStream* __is)
{
    __is->startReadSlice();
    __is->endReadSlice();
}

void 
SettingValue::__patch(CSettingValueFepPtr& handle, const ::Ice::ObjectPtr& v)
{
    handle = ::SettingValue::CSettingValueFepPtr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(::SettingValue::CSettingValueFep::ice_staticId(), v);
    }
}
